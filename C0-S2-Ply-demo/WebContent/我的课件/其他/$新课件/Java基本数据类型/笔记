1. 为什么浮点数的最大值和最小值规则和整数的不一样? 
	byte 的取值范围：-128～127（-2的7次方到2的7次方-1）
	short 的取值范围：-32768～32767（-2的15次方到2的15次方-1）
	int 的取值范围：-2147483648～2147483647（-2的31次方到2的31次方-1）
	long 的取值范围：-9223372036854774808～9223372036854774807（-2的63次方到2的63次方-1）
	
	float（单精度浮点型）取值范围：3.402823e+38～1.401298e-45（e+38 表示乘以10的38次方，而e-45 表示乘以10的负45次方）
	指数: 8位
	double（双精度浮点型）取值范围：1.797693e+308～4.9000000e-324（同上）
	指数: 11位
	
2. double和float精度问题
	float或double精确的表示0.1或者10的任何其他负数次方值是不可能的!!!
	道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10
	例子: 	0.1+0.2 = 0.30000000000004
	
		0.22f != 0.22
		
		float f = 1234567831239f; // 值要足够大
		float f1 = f + 1;
		boolean res = f == f1; 
	
	解决方案: BigDecimal
	
3. Java中两个byte类型相加结果赋值给byte类型的变量会报编译错误，byte加byte的结果为什么是int？
	原因: 被转成int进行计算
		原因: 底层运算指令只有256个, 只能精简一些数据类型的运算指令
		
		
3. java包装类的缓存机制
	https://www.cnblogs.com/myseries/p/12076828.html
	现象 ==> 原因 ==> 场景

http://47.106.66.89:1112/demo/%E6%88%91%E7%9A%84%E8%AF%BE%E4%BB%B6/%E5%85%B6%E4%BB%96/$%E6%96%B0%E8%AF%BE%E4%BB%B6/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html
