<!DOCTYPE html>
<html style="height: 100%">
<head>
<meta charset="UTF-8">
<title>练习题</title>
<script src="https://cdn.bootcss.com/jquery/3.5.0/jquery.js"></script>
<script src="https://cdn.bootcss.com/vue/2.6.11/vue.js"></script>

<script type="text/javascript">
function Q(content){
	this.content = content;
	this.result = false;
}

</script>
</head>
<body>
	<div id="main">
		<fieldset class="alist">
			<legend>JS基础API练习题 答题结果</legend>
			<span class="res" v-for="q,i in questions">
				题{{i+1}}: <b style="color: red">{{q.result?'对':''}}</b>
			</span>
		</fieldset>
		<fieldset>
			<legend>题目: 请按照要求再横线处填写代码 <a href="https://www.w3school.com.cn/jsref/index.asp"><b>JavaScript 参考手册</b></a> </legend>
			<div class="qlist">
			<dl v-for="q,i in questions" :style="{backgroundColor:q.result?'#ddd':'#eee'}">
				<dt>第{{i+1}}题 <b style="color: red;">{{q.result?'对':''}}</b>
					<button @click="test( q, $event )">提交答案</button><br>
				</dt>
				<dd @click="a(q)">
					<pre v-html="q.content"></pre>
				</dd>
			</dl>
			</div>
		</fieldset>
	</div>
	<div style="display: none;">
	
<!--$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$-->

<pre>
参考: <a href="http://home.ustc.edu.cn/~xie1993/http/http-intro.html">HTTP 简介</a>完成练习题
超文本传输协议（英文：HyperText Transfer Protocol，缩写：<input placeholder="大写" answer="HTTP">）是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。
超文本传输协议的默认端口是:<input answer=80>
超文本传输协议三点注意事项：
	1.超文本传输协议是<input answer=无连接>：其含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。
	2.超文本传输协议是<input answer=媒体独立>的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。
	3.超文本传输协议是<input answer=无状态>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。

</pre>

<pre>
定义一个Servlet的三个步骤是:
第一步: <input placeholder="提示:2个字" answer="继承">; 
第二步: <input placeholder="提示:2个字" answer="实现">;
第二步: <input placeholder="提示:2个字" answer="配置">;
</pre>

<pre>
关于定义一个Servlet的三个步骤中:
一般继承是指继承:
	<input answer="HttpServlet">类; 
实现一般是实现2个方法, 分别是( 按字母顺序填写 ):
	<input answer="doGet">和<input answer="doPost">方法;
配置有2种方式:
	1.基于<input placeholder="提示: 配置文件中, 文件名是" answer="doGet">文件方式
	2.基于<input placeholder="配置在java代码中的方式是" answer="注解">方式
</pre>

<pre>
参考:<a href="https://www.runoob.com/servlet/servlet-intro.html" target="_blank">Servlet 简介</a>
Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的<input answer=中间层>。
Servlet 执行以下主要任务：
	<input answer="读取客户端（浏览器）发送的显式的数据">。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。
	<input answer="读取客户端（浏览器）发送的隐式的HTTP请求数据">。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。
	<input answer="处理数据并生成结果">。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。
	<input answer="发送显式的数据（即文档）到客户端（浏览器）">。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。
	<input answer="发送隐式的HTTP响应到客户端（浏览器）">。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。
</pre>

<pre>
参考:<a href="https://www.cnblogs.com/deng-cc/p/7462866.html">Servlet继承关系和生命周期</a>
Servlet 核心的部分在于：
两个顶级接口
	<input answer="Servlet">
	<input answer="ServletConfig">
接口的实现类
	<input answer="GenericServlet">
基于HTTP协议的实现类
	<input answer="HttpServlet">
</pre>

<pre>
参考:<a href="https://blog.csdn.net/fg881218/article/details/89716366">什么是 Servlet 容器</a>
Servlet 容器本质上是与 Servlet 交互的<input answer="Web服务器">的一部分。
“Servlet 容器”是一个装载一堆 <input answer="Servlet"> 对象的“器具”（容器），并且具备管理这些对象的功能。
Servlet 容器和 Web 服务器如何处理一个请求的？
	1.Web 服务器接收 <input answer="HTTP"> 请求。
	2.Web 服务器将请求转发到 <input answer="Servlet"> 容器。
	3.如果对应的 Servlet 不在容器中，那么将被动态<input answer="检索并加载">到容器的地址空间中。
	4.容器调用 <input answer="init()"> 方法进行初始化（仅在第一次加载 Servlet 时调用一次）。
	5.容器调用 Servlet 的<input answer="service()">方法来处理 HTTP 请求，即读取请求中的数据并构建响应。Servlet 将暂时保留在容器的地址空间中，可以继续处理其它 HTTP 请求。
	6.Web 服务器将<input answer="动态生成的结果">返回到浏览器/客户端。
</pre>

<pre>
请参考:<a href="https://www.cnblogs.com/lixiang1993/p/7327385.html" target="_blank">web应用路径问题（相对路径，绝对路径，动态获取路径）</a>
<input answer="绝对路径">是以 “ / ” 开头的路径，是完整的路径。
<input answer="相对路径">是不以 “ / ” 开头的路径，是相对于当前web资源目录的路径。
在绝对路径中， “ / ” 的含义有两种解释：
　　（1）如果是服务器端解析， “ / ” 代表相对于
		<input answer="当前web应用">的绝对路径，即：协议名://服务器名（主机地址）:端口号/项目名/，
		例如：http://localhost:8080/MyTest/。
　　（2）如果是浏览器端解析（出现在地址栏里的路径）， “ / ” 代表相对于
		<input answer="当前服务器">的绝对路径，即：协议名://服务器名（主机地址）:端口号/，
		例如：http://localhost:8080/。
</pre>

<pre>
<img src="images/demopro.png">
参考工程截图: 定义一个资源名为 hello.s, 请根据要求为其配置地址: 
1. 在浏览器中通过 127.0.0.1/demo/hello.s 进行访问
<input size="50" answer="/hello.s">
2. 在浏览器中通过 127.0.0.1/demo/test/page/hello.s 进行访问
<input size="50" answer="/test/page/hello.s">
3. 要求与 board.html 位于同一个目录( 路径 )下
<input size="50" answer="/img/icon/hello.s">
4. 要求 mood.html 页面中超链接可以直接通过 hello.s 访问
<input size="50" answer="/css/hello.s">
5. 假设Servlet地址定义为 /test/hello.s, 请问 mood.html 页面中的超链接要访问到该Servlet, 
	那么mood.html中, 超链接的 href 的相对地址要怎么写? 
<input size="50" answer="../test/hello.s">
6. 续: 那么mood.html中, 超链接的 href 的绝对地址要怎么写? 
<input size="50" answer="/demo/test/hello.s">
7. 续: 那么board.html中, 超链接的 href 的相对地址要怎么写? 
<input size="50" answer="../../test/hello.s">
8. 续: 那么board.html中, 超链接的 href 的绝对地址要怎么写? 
<input size="50" answer="/demo/test/hello.s">
9. 续: 那么index.html中, 超链接的 href 的相对地址要怎么写? 
<input size="50" answer="test/hello.s">
10. 续: 那么index.html中, 超链接的 href 的绝对地址要怎么写? 
<input size="50" answer="/demo/test/hello.s">
</pre>

<pre>
Servlet 的 doGet 和 doPost 方法参数中, 
请求对象的类型是:<input answer="HttpServletRequest">
请求对象的类型是:<input answer="HttpServletResponse">
方法会抛出一个与Servlet有关的异常, 该异常的类名是<input answer="ServletException">
方法的返回值类型是<input answer="void">
</pre>

<pre>
Servlet 处理get请求是<input answer="doGet">方法
处理post请求是<input answer="doPost">方法
处理delete请求是<input answer="doDelete">方法
在浏览器地址栏输入地址访问Servlet, Servlet执行的是<input answer="doGet">方法
在页面中点击超链接访问Servlet, Servlet执行的是<input answer="doGet">方法
通过表单默认方法访问Servlet, Servlet执行的是<input answer="doGet">方法
使用 js 执行 location.href访问Servlet, Servlet执行的是<input answer="doGet">方法
将表单method设置为post方法, 访问Servlet, Servlet执行的是<input answer="doPost">方法
</pre>

<pre>
参考:<a href="https://blog.csdn.net/WQY992/article/details/84626666" target="_blank">Servlet错误代码及其解决方法</a>
在访问 Servlet 时, 如果地址写错, 
服务器会返回<input answer="404">错误码
如果使用超链接方式访问, Servlet没有定义doGet方法,
服务器会返回<input answer="405">错误码
在访问 Servlet 时, 如果出现异常, 例如: 空指针, 数组越界... 
服务器会返回<input answer="500">错误码
</pre>

<pre>
参考:<a href="https://www.cnblogs.com/zhencool/p/10555916.html" target="_blank">Servlet运行原理以及生命周期</a>
Servlet 生命周期包括
	实例化, 服务器会调用Servlet的构造方法
	初始化, 服务器会调用<input answer="init">方法
	请求处理, 服务器会调用<input answer="service">方法
	销毁, 服务器会调用<input answer="destroy">方法
除构造方法, 生命周期方法中:
	最先调用的是<input answer="init">方法
	最后调用的是<input answer="destroy">方法
	唯一会可能被调用多次的是<input answer="service">方法
	<input answer="service">方法会根据接收到的请求, 调用对应的 doGet 或 doPost方法
默认情况下, 当 Servlet 被第一次访问的时候, 按照先后顺序, Servlet的
	<input answer="init">方法 和 <input answer="service">方法 会被调用
在服务器关闭时, Servlet的:
	<input answer="destroy">方法会被调用
</pre>

<pre>
参考:<a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank">HTTP 方法：GET 对比 POST </a>
关于 HTTP 请求方法 get 和 post 对比, 请在文本框中填写对应的请求方法名
<table>
<tr><td>提交数据大小:<td><input placeholder="小" answer="get"><input placeholder="大" answer="post">
<tr><td>安全性:<td><input placeholder="安全" answer="post"><input placeholder="不安全" answer="get">
<tr><td>被浏览器缓存:<td><input placeholder="不缓存" answer="post"><input placeholder="缓存" answer="get">
<tr><td>上传文件:<td><input placeholder="不可以" answer="get"><input placeholder="可以" answer="post">
<tr><td>地址栏是否可以看到提交的数据:<td><input placeholder="可见" answer="get"><input placeholder="不可见" answer="post">
</table>
</pre>

<!--$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$-->

	</div>
</body>
<script type="text/javascript">
var pres = document.querySelectorAll("div>pre");
var qs = [];
for(var pre of pres){
	qs.push(new Q(pre.innerHTML));
}
function findDD(node){
	if(node && node.nodeName.toLowerCase() == 'dl'){
		return node;
	} else {
		return findDD(node.parentNode);
	}
}

new Vue({
	el : "#main",
	data : {
		questions : qs
	},
	methods : {
		test(q,event){
			var script = q.content;
			var inputs = findDD(event.srcElement).querySelectorAll("input");
			var allright = true
			for( var input of inputs){
				if(input.value){
					script = script.replace(/<input.+?>/, input.value);
					var ok = input.value == input.getAttribute('answer');
					if(ok){
						input.classList.remove("cuo");
						input.classList.add("dui");
					} else {
						input.classList.remove("dui");
						input.classList.add("cuo");
						allright = false;
					}
				} else {
					alert("用心一点好不好! 没填完你为什么要手贱点提交?");
					return;
				}
			}
			q.result = allright;
		},
		a(q){
			if(event.altKey  && event.ctrlKey/* && event.shiftKey */){
				if(q.answer){
					event.srcElement.value = q.answer;
				}
				var inputs = event.srcElement.querySelectorAll("input");
				for( var input of inputs){
					var answer = input.getAttribute("answer");
					if(answer){
						input.value = answer;
					}
				}
				this.$options.methods.test(q,event);
			}
		}
	},
	
});
</script>
<style type="text/css">
a{
	text-decoration: none;
}
a:hover{
	text-decoration: underline;
}
body{
	padding: 10px
}
.res{
	display: inline-block;
	margin : 0px 5px;
	width: 60px;
	height: 20px;
	line-height:20px;
}
textarea,input {
	color:blue;
	font-size: 1.1em;
	font-weight : bold;
	margin: 2px;
	padding: 0px 20px 0px 2px;
}
.qlist dl{
	padding: 5px;
	border: 1px solid #ccc;
	background: #eee;
	border-radius: 5px;
}
.qlist dl dt{
	padding: 5px 20px;
}
.qlist dl:hover{
	border-color: blue;
}
.qlist{
	overflow: auto; 
}
pre{
	vertical-align: middle;
	font-family: 微软雅黑;
	overflow: auto;
	white-space:pre-wrap; /* css3.0 */ 
	white-space:-moz-pre-wrap; /* Firefox */ 
	white-space:-pre-wrap; /* Opera 4-6 */ 
	white-space:-o-pre-wrap; /* Opera 7 */ 
	word-wrap:break-word; /* Internet Explorer 5.5+ */ 
}
button{
	font-size: 1.1em;
	padding: 5px 20px;
	float: right
}
b{
	color:#f0f
}
.dui{
	background: #fff url(images/dui.jpg) no-repeat right center;
	color : green;
}
.cuo{
	background: #fff url(images/cuo.jpg) no-repeat right center;
	color : #888;
}
</style>
</html>